"""Integration with the DAT auditing pipeline."""

from __future__ import annotations

import json
import os
import subprocess
from pathlib import Path
from typing import Dict, Optional, Sequence

CONFIG_PATH = Path.home() / ".config" / "lrc" / "dat_integration.json"


class DataAuditResult(Dict[str, str]):
    """Simple dictionary-based container for audit metadata."""


def _load_config(config_path: Path = CONFIG_PATH) -> Optional[Dict[str, object]]:
    if not config_path.exists():
        return None
    try:
        return json.loads(config_path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"Invalid DAT integration config: {exc}") from exc


def _coerce_command(command: object) -> Sequence[str]:
    if isinstance(command, str):
        return command.split()
    if isinstance(command, (list, tuple)):
        return [str(part) for part in command]
    raise TypeError("DAT integration command must be a string or sequence")


def run_dat_audit(
    build_dir: Path, *, logger=print, config_path: Path = CONFIG_PATH
) -> DataAuditResult:
    """Run the DAT audit pipeline if it is configured.

    Parameters
    ----------
    build_dir:
        Directory that was generated by LRC.
    logger:
        Callable used to emit log lines.  Defaults to :func:`print`.
    config_path:
        Location of the DAT integration configuration file.

    Returns
    -------
    DataAuditResult
        Mapping containing the status and captured output.
    """

    cfg = _load_config(config_path)
    result: DataAuditResult = DataAuditResult()
    result["status"] = "skipped"

    if not cfg:
        logger("[AUDIT] DAT integration config not found; skipping")
        return result

    if not cfg.get("enabled", True):
        logger("[AUDIT] DAT integration disabled in config")
        return result

    command = _coerce_command(cfg.get("command", ["dat", "audit"]))
    args = list(command)
    if "${BUILD_DIR}" in args:
        args = [part.replace("${BUILD_DIR}", str(build_dir)) for part in args]
    else:
        args.append(str(build_dir))

    env = os.environ.copy()
    extra_env = cfg.get("env")
    if isinstance(extra_env, dict):
        env.update({str(k): str(v) for k, v in extra_env.items()})

    logger(f"[AUDIT] Running: {' '.join(args)}")

    try:
        completed = subprocess.run(
            args,
            cwd=str(build_dir),
            env=env,
            capture_output=True,
            text=True,
            check=False,
        )
    except FileNotFoundError as exc:
        raise RuntimeError(f"DAT command not found: {args[0]}") from exc

    result["stdout"] = completed.stdout.strip()
    result["stderr"] = completed.stderr.strip()
    result["returncode"] = str(completed.returncode)

    if completed.returncode == 0:
        result["status"] = "passed"
        logger("[AUDIT] DAT audit completed successfully")
    else:
        result["status"] = "failed"
        logger("[AUDIT] DAT audit reported issues")
        if completed.stderr:
            logger(completed.stderr)

    if completed.stdout:
        logger(completed.stdout)

    return result
